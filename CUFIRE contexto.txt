Te voy a explicarle bien la l√≥gica para que me entiendas lo que quiero y me realices todo el backend con FastAPI, que veo que es f√°cil de integrar, es decir, es robusto, con Quasar y despu√©s la integraci√≥n con Unity por supuesto. Para la integraci√≥n con Unity te voy a dar luego las diferentes pantallas que tengo en mi juego y que archivos se usan en cada pantalla para que los analices y lo integres directamente con todo este backend, con todo este ecosistema. ¬øQu√© quiero? La l√≥gica es un, ya sabes que es de torneo, los jugadores pueden jugar libremente sin pagar y eso lleva una tabla clasificadora, es decir, la tabla se va actualizando siempre en tiempo real seg√∫n la puntuaci√≥n de los jugadores. Ahora, quiero hacer tambi√©n el torneo, es decir, para participar en el torneo ya el usuario si tiene que abonar o pagar 10 USDT para tener la posibilidad de participar en los beneficios de la repartici√≥n despu√©s de terminado el torneo, participar de los beneficios de la repartici√≥n, de la recaudaci√≥n del torneo, del premio, para obtener, tiene derecho a los beneficios de la repartici√≥n del premio. De todos los recaudados se va a registrar en el torneo, si tienen una fecha l√≠mite para registrarse en el torneo, si se va a hacer, puede ser as√≠ o puede ser que se va llenando hasta un l√≠mite que yo determine de usuarios, ya cuando llegue ese l√≠mite de usuarios pues se cierra ya el torneo, se va llenando din√°micamente, de forma gr√°fica se ve en la p√°gina como se va llenando una bolsa de dinero o una pir√°mide de monedas que va llen√°ndose, es una forma gr√°fica bastante atractiva y profesional donde se da al usuario el porcentaje que falta para que empiece el torneo, puede ser as√≠, b√°sicamente es eso, cada usuario cuando entre, siempre cuando se registre un usuario debe entrar, ya sea si va a participar en el torneo o no, tiene que entrar su billetera usdt para en el caso que decida posteriormente abonar los 10 usdt ya est√© habilitada esa billetera y entonces si participan ya en el torneo, que entre los 10 primeros lugares pueden ya entregarle, enviarle su parte del premio si entra dentro de los 10 primeros lugares, ahora todo eso, todo ese ecosistema tienes que prepar√°rmelo, dime si entendiste s√≠ o no y procede hacerme todo eso.


S√≠, entend√≠ perfectamente. Has planteado una l√≥gica muy clara para un sistema de torneos en l√≠nea con dos tipos de participaci√≥n (gratuita y pagada), tabla de puntuaciones en tiempo real, gesti√≥n de pagos en USDT, y entrega de premios a los ganadores. Te resumo los puntos clave y luego te explico c√≥mo vamos a organizar todo el desarrollo con FastAPI (backend), Quasar (frontend) y Unity (juego).
‚úÖ RESUMEN DE LA L√ìGICA GENERAL:
1. Registro de usuarios

    Datos requeridos: email, contrase√±a, clave maestra para recuperaci√≥n y direcci√≥n USDT (TRC20, ERC20 o especificar).

    Se almacenan en la base de datos.

2. Participaci√≥n

    Modo libre (gratuito):

        Cualquier usuario puede jugar sin pagar.

        Aparece en una tabla clasificatoria global.

    Modo torneo (pagado):

        Para participar, debe pagar 10 USDT.

        Solo jugadores que pagan aparecen en la tabla del torneo.

        Solo estos jugadores tienen derecho al premio.

        El torneo tiene:

            Fecha l√≠mite para registro O

            L√≠mite de jugadores registrados (el que llegue primero).

        Se muestra visualmente el progreso del fondo acumulado del torneo.

3. Premiaci√≥n

    Al finalizar el torneo:

        Se calcula el total recaudado.

        El 50% se reparte entre los 10 primeros lugares con porcentajes espec√≠ficos.

        Se efect√∫a el pago a las billeteras USDT registradas.

        Se muestra en frontend los ganadores y sus premios.

4. Frontend

    Visual atractivo tipo gaming.

    Muestra pir√°mide o barra de progreso del fondo recaudado.

    Cuenta regresiva o barra de llenado.

    Vista de tabla clasificatoria en tiempo real.

    Vista del torneo y sus reglas.

5. Unity

    Se conecta para:

        Login.

        Cargar perfil.

        Recuperar score global o de torneo.

        Subir puntuaciones en tiempo real.

        Mostrar tabla clasificatoria.

Esto es un ejemplo se puede ajustar los porcentajes luego. Por lo que el backend debe permitir administrar esto y el maximo de recaudacion antes de empesar el torneo es decir el monto a recaudar para que se complete el llenado una ves se llegue a ese monto empiesa el torneo, que durara el tiempo que se proporciona tamnbien en la configuracion.
Tu modelo explicado de forma clara

    Juego gratuito para todos

        Cualquier usuario puede jugar sin pagar.

        Pueden practicar, mejorar, subir en el ranking no competitivo.

    Torneo especial (modo competitivo)

        Pagar 10 USDT (v√≠a wallet o c√≥digo de activaci√≥n).

        Al activar el torneo, se les habilita la participaci√≥n por el ranking oficial.

        Se reparte el total recaudado entre los 10 mejores.

    Distribuci√≥n del premio (ejemplo):

Puesto	Porcentaje del total recaudado
ü•á 1¬∫	35‚ÄØ%
ü•à 2¬∫	20‚ÄØ%
ü•â 3¬∫	15‚ÄØ%
ü•â 4¬∫	10‚ÄØ%
ü•â 5¬∫	7‚ÄØ%
ü•â 6¬∫‚Äì10¬∫ 2‚ÄØ% cada uno


Quiero que revises y me expliques bien como hago el flujo de registrar y la participacion paga y gratis de un torneo y en caso de pagar para participar un torneo como se paga ahi te dejo mis archivos para que resuelvas eso y me expliques bien sin tantos detalles pero si bien claro para entender. Dime como hago todo el flujo incluyendo una billetera TRC20 de prueba y automatizando todo el pago y la verificacion del mismo una ves sea realizado por un participante ya registrado. Simular tambien la entrada de puntos es decir tanto para el score global como para el del torneo como si estuviera ya conectado todo este al juego.

//Backend//

1- Cuando no me he registrado en ningun torneo lo que significa que no he pagado no tengo que ingresar el id del torneo para registrar mi score ya que ira al Leaderboard Global el id es necesario si estoy registrado en ese id de torneo y ahi si ira al Leaderboard del Torneo en donde este registrado. Actualmente si no he pagado no puedo entrar el score eso esta bien. Si estoy jugando sin pagar no tengo que ingresar id.
2- El score cuando es para torneo pagado no se debe dejar entrar el score hasta que no cierren las inscripciones ya sea hasta que se alcance el objetivo del monto maximo o alcance el maximo de Participantes una ves pase esto no se admiten mas registros a ese torneo y comienza la cuenta atras segun se haya definido en la variable de la base de datos duration.

//Frontend//
1- No manda alerta y debe hacerse con swettalert para todas las alertas ya sean de errores o cuando se hace un registro o login correcto.
2- El proceso de Inscripci√≥n al torneo no se realiza correctamente no sigue el flujo que me diste. Hacer el pago a la billetera que aun no esta definida usa una de prueba para mi app, Verificar mandando el hash de confirmacion y Registrar en torneo.
3- En el Dasboard del Admin debo poder Getionar usuarios es decir editarlos y eliminarlos asi como crear torneos que no me deja actualmente sin embargo desde swager el backend si puedo, debo poder al terminar el torneo cuando la cuenta regresiva de la variable duration llegue a cero se pondra la variable is_active a false y una ves se proceda  a dar clic desde el boton DISTRIBUIR PREMIOS (TOP 10) se mostrara el Leaderboard del Torneo en TournamentDetails como quedo el final de la tabla con los Usuario, Puntuacion, Premio(segun porcentaje segun tabla) y Fecha. esta es la tabla de porcentaje para repartir el premio:
ü•á 1¬∫	35‚ÄØ%
ü•à 2¬∫	20‚ÄØ%
ü•â 3¬∫	15‚ÄØ%
ü•â 4¬∫	10‚ÄØ%
ü•â 5¬∫	7‚ÄØ%
ü•â 6¬∫‚Äì10¬∫ 2‚ÄØ% cada uno
La tabla Leaderboard del Torneo delante del # debe tener un icono bien chulo segun su posicion sera el color del metal. Una ves duration llegue a cero tendre un boton para eliminar el  torneo en cascada para que se borre todo lo asociado a el.

//Frontend//
4- En esta ruta http://localhost:9000/#/tournaments/1 que es la de TournamentDetail el boton "unirme al torneo (10 USDT)" esta desabilitado


1- Para torneo pagado no se debe dejar entrar el score hasta que no cierren las inscripciones hasta que se alcance el objetivo del premio es decir que current_amount max_amount una ves pase esto no se admiten mas registros a ese torneo y comienza la cuenta atras segun se haya definido en la variable de la base de datos duration. En javaScript hacer un contador atras segun el tiempo definido en duration que esta en minutos, cuanto ese cronometro llegue a cero is_active = false el torneo dira en la pagina HomePage.vue  <q-badge color="purple-5" v-if="tournament.start_date">Cuenta atr√°s</q-badge> cuenta atras se sustituye por Terminado y no se permiten mas scores ni mas registros al mismo lo que significa que cuando se de clic y se entre a la pagina TournamentDetail el boton de Unirme al Torneo(10 USDT) estara desabilitado porque is_active = false pero se seguira viendo hasta que se elimine el mismo y ahi no se vera logicamente en HomePage.vue. En TournamentDetails debe mostrar un boton que diga Distribuir Premio que mostrara una ventana swettalert con la distribuciondashboard del Premio segun monto total el objetivo(max_amount)(segun porcentaje segun tabla)  esta es la tabla de porcentaje para repartir el premio:
ü•á 1st: 30% 
ü•à 2nd: 18% 
ü•â 3rd: 13%
ü•â 4th: 9% 
ü•â 5th: 5% 
ü•â 6th‚Äì10th: 5% cada uno. Este calculo se hara con javascript y muestra por ejemplo digamos que max_amount = 1000 USDT se aplica los % de la tabla en los 10 lugares. 
Arregla en el d
En la pagina DashboardPage.vue cuando se entra como Administrador la parte de gestionar usuarios si funciona, el formulario para crear torneo no funciona arreglar eso ver en tournament.py ver el enpoint /api/tournaments/ ahi se hace ese registro actualmente cuando escojo una fecha se borra la otra no se porque. Se debe poder eliminar torneos para ello se debe crear ese enpoint es decir la funcion que ahora no existe y poder eliminar desde la tabla Torneos. Se elimina en cascada las referencias de las tablas payments y tournament_registrations.

2-  El proceso de Inscripci√≥n al torneo no se realiza correctamente no sigue el flujo. Hacer el registro al torneo solo si no se ha alcanzado el monto_maximo o alcance el maximo de Participantes, Registrar en torneo segun enpoint /api/tournaments/{id}/register y Verificar mandando el hash de confirmacion(Si el tx_hash de la tabla payments lo compruebo manualmente y si es correcto le pongo en la tabla payments hay que crear un is_active lo pongo en true si es correcto y false en caso contrario esta logica tambien debo manejarla desde el DashboardPage.vue).

En Premio Total en la pagina Inicio se debe ver una imagen vectorial de una copa con efecto de llenado con css espectacular como se hace en vue ejemple en el file CupFlame.vue.

En alg√∫n lugar cuando me logueo como Administrador debe poder gestionar tanto usuarios como torneos(Crear,Actualizar y Eliminar)

El proceso de inscripci√≥n a un torneo y del pago de los 10 usdt para participar en el reparto del premio, y verificaci√≥n del mismo para activar a ese usuario como lo manejas y donde, si no esta hecho hazlo bien profesional.

Los ficheros de Unity Server.cs y web.cs (manejan la logica de Login, leer u escribir puntuaciones, entre otras) no deben ser tocados se quedaran intactos los proporciono para que toda la l√≥gica del backend y frontend se basen en ellos por ejemplo cuando se realiza un nuevo hiscore ya tuvimos que habernos loguiado en Unity por lo que el juego maneja y sabe que usuario es, el backend debe manejar bien que datos mostrar para poblar la tabla de hiscore dentro de Unity en dependencia si el usuario esta jugando gratis o esta inscrito en un torneo me parece conveniente que un usuario este inscrito solo en un torneo no se como lo manejaras mejor, as√≠ mismo para escribir puntos debe determinar el backend hacia donde van en dependencia si el usuario esta jugando gratis o esta inscrito en un torneo.

No se si tienes esto previsto hay que hacer algo como esto una l√≥gica bien elaborada para torneo, propon una mejor que maneje todo. Ejemplo, prop√≥n una mejor a esta aqu√≠ esta. Para torneo pagado no se debe dejar entrar el score hasta que no cierren las inscripciones hasta que se alcance el objetivo del premio es decir que current_amount max_amount una ves pase esto no se admiten mas registros a ese torneo y comienza la cuenta atras segun se haya definido en la variable de la base de datos duration. En javaScript hacer un contador atras segun el tiempo definido en duration que esta en minutos, cuanto ese cronometro llegue a cero is_active = false el torneo dira en la pagina HomePage.vue  <q-badge color="purple-5" v-if="tournament.start_date">Cuenta atr√°s</q-badge> cuenta atras se sustituye por Terminado y no se permiten mas scores ni mas registros al mismo lo que significa que cuando se de clic y se entre a la pagina TournamentDetail el boton de Unirme al Torneo(10 USDT) estara desabilitado porque is_active = false pero se seguira viendo hasta que se elimine el mismo y ahi no se vera logicamente en HomePage.vue. En TournamentDetails debe mostrar un boton que diga Distribuir Premio que mostrara una ventana swettalert con la distribuciondashboard del Premio segun monto total el objetivo(max_amount)(segun porcentaje segun tabla)  esta es la tabla de porcentaje para repartir el premio:

ü•á 1st: 30% 

ü•à 2nd: 18% 

ü•â 3rd: 13%

ü•â 4th: 9% 

ü•â 5th: 5% 

ü•â 6th‚Äì10th: 5% cada uno 

//Modelos//

# user.py
from app.db.base import Base
from sqlalchemy import Boolean, Column, Integer, String

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True)
    email = Column(String, unique=True, index=True)
    hashed_password = Column(String)
    usdt_wallet = Column(String, nullable=True)
    is_active = Column(Boolean, default=True)
    is_tournament_participant = Column(Boolean, default=False)
    is_admin = Column(Boolean, default=False)  # Nuevo campo para administrador

# tournament.py    
from app.db.base import Base
from sqlalchemy import Column, Integer, String, Float, DateTime, Boolean
from datetime import datetime

class Tournament(Base):
    __tablename__ = "tournaments"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    description = Column(String, nullable=True)
    max_players = Column(Integer, nullable=True)
    max_amount = Column(Float, nullable=True)  # Monto m√°ximo recaudado
    current_amount = Column(Float, default=0.0)
    registration_fee = Column(Float, default=10.0)  # 10 USDT
    start_date = Column(DateTime, nullable=True)
    end_date = Column(DateTime, nullable=True)
    duration = Column(Integer, nullable=True)  # En minutos
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)

# tournament_registration.py
from app.db.base import Base
from sqlalchemy import Column, Integer, ForeignKey, DateTime
from datetime import datetime

class TournamentRegistration(Base):
    __tablename__ = "tournament_registrations"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)
    tournament_id = Column(Integer, ForeignKey('tournaments.id'), nullable=False)
    registered_at = Column(DateTime, default=datetime.utcnow)

# payment.py
from sqlalchemy import Column, Integer, String, ForeignKey, DateTime, Float, Boolean
from app.db.base import Base

class Payment(Base):
    __tablename__ = "payments"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete='CASCADE'))
    tournament_id = Column(Integer, ForeignKey("tournaments.id", ondelete='CASCADE'))
    tx_hash = Column(String, nullable=True)
    amount = Column(Float)
    created_at = Column(DateTime)
    is_active = Column(Boolean, default=False)

# score.py
from sqlalchemy import Column, Integer, ForeignKey, String, DateTime
from app.db.base import Base
from datetime import datetime

class Score(Base):
    __tablename__ = "scores"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    tournament_id = Column(Integer, ForeignKey("tournaments.id"), nullable=True)
    value = Column(Integer)
    mode = Column(String)  # 'free' o 'tournament'
    created_at = Column(DateTime, default=datetime.utcnow)
    

//Requisitos Funcionales//
1- En registrar user no puede haber una billetera repetida en el sistema(validar en el backend eso), al igual que el nombre y email no deben estar repetidos en la base de datos(Estos si creo estan validados confirmar eso).
2- Un usuario solo puede estar registrado a un torneo, por lo que hay que verificar si ya esta registrado en algun torneo y no permitir pagar para registrarse en otro.
3- No debe permitir entrar scores al Leaderboard del Torneo si este no esta En Curso, cuando esta en estado Open o Finalizado no se puede permitir estrar scores. Cuando un usuario no esta inscrito a un torneo significa que esta jugando en modo gratis y el score que haga en el juego sera enviado al Leaderboard Global. 
Los ficheros de Unity Server.cs y web.cs (manejan la logica de Login, leer y escribir puntuaciones, entre otras) no deben ser tocados se quedaran intactos los proporciono para que toda la l√≥gica del backend y frontend se basen en ellos por ejemplo cuando se realiza un nuevo hiscore ya tuvimos que habernos loguiado en Unity por lo que el juego maneja y sabe que usuario es, el backend debe manejar bien que datos mostrar(leer puntos) para poblar la tabla de hiscore dentro de Unity en dependencia si el usuario esta jugando gratis o esta inscrito en un torneo me parece conveniente que un usuario este inscrito solo en un torneo, as√≠ mismo para (escribir puntos) debe determinar el backend hacia donde van en dependencia si el usuario esta jugando gratis o esta inscrito en un torneo.

4- Rectificar el proceso completo de inscripcion al torneo. El proceso de Inscripci√≥n al torneo no se realiza correctamente no sigue el flujo. Hacer el registro al torneo solo si el usuario no esta registrado en un torneo y si en la tabla tournaments current_amount < max_amount estado en frontend" Open(significa abierto a inscripciones), si current_amount = max_amount(que es el objetivo) se pone "estado en fronted" En Curso(significa que esta iniciado la cuenta atras con un cronometro segun el tiempo puesto en la tabla tournaments en el campo duration y el torneo ya cerro las inscripciones). En estos dos casos en la tabla tournaments el campo is_active=true. Cuando ese cronometro llegue a cero en la tabla tournaments el campo is_active=false se pone "estado en fronted" Finalizado(significa que el torneo termino). Actualmente el usuario se inscribe al torneo, hace el pago y manda el thash de la confirmacion del mismo y se le debe poner en el frontend estado pendiente en la tabla payments el campo is_active = false, el administrador manualmente lo verifica y le cambia el estado a verificado en el frontend en la tabla payments el campo is_active inicialmente en false se le cambia a true. En el frontend en la parte de detalles del torneo hay un boton Unirme al torneo este estara desactivado o activado en dependencia si el usurio logueado esta inscrito en un torneo(Esta activo el boton si el usuario no esta inscrito en un torneo en caso contrario esta desabilitado) este booton lanza un formulario que debe recoger la billetera del usuario logueado. Desde el DashboardPage.vue con mi usuario administrador ya puedo escoger de un torneo los usuarios registrados a el y activarlos odesactivarlos actualmente esta implementado pero hay que revisar todo el proceso antes descrito para lograr e integrar todo de la mejor manera siguiendo las mejores practicas sin modificar la base de datos actual. Buscar la manera mas logica para hacer la inscripcion.

cufireUrl.json actualizar segun los enpoint del backend que manejen la logica: 
```json
{
  "login": "http://your-domain/api/auth/login",
  "register": "http://your-domain/api/auth/register",
  "readscore": "http://your-domain/api/scores/global", //logica manejada x backend si user esta jugando gratis o no
  "writescore": "http://your-domain/api/scores/submit" //logica manejada x backend si user esta jugando gratis o no
}
```
Este es mi repositorio. Consultar siempre para estar al d√≠a con las √∫ltimas actualizaciones
https://github.com/agrdev85/FPS-CUFIRE-Server 

Listo para clonar 
https://github.com/agrdev85/FPS-CUFIRE-Server.git

Google Drive
https://drive.google.com/drive/folders/1acgGCrdPHR8uW-aORCqlXfOJMWbbbMsJ?usp=sharing
 
Antes de hacer codigo planteame la mejor manera de hacer esto sin tocar los archivos de Unity web y Server, ni la base de datos. 
siempre  h√°blame en espa√±ol

1. Principio de dise√±o

No tocar Unity: Unity seguir√° usando los endpoints definidos en cufireUrl.json. El backend debe adaptarse a c√≥mo Unity env√≠a login/requests (ya provisto).

No cambiar esquema de BD: Usaremos las tablas existentes y a√±adiremos validaciones y consultas sobre ellas. No migraciones.

Separaci√≥n de responsabilidades:

API REST (Flask) para autenticaci√≥n, registro, torneos, pagos, scores, administraci√≥n.

Real-time: Flask-SocketIO (con Redis como message broker si se escala). Unity podr√° usar WS si lo soporta, si no, el frontend poll/long-poll.

Worker/cron: tarea peri√≥dica que actualiza estados de torneos (Open ‚Üí En Curso ‚Üí Finalizado) y calcula premios cuando finaliza. Inicialmente puede ser un cron job o un proceso separado en el mismo servidor.

2. Estados de torneo y reglas (definici√≥n concreta)

Estado interno inferido en backend (no se a√±ade campo nuevo):

Open: is_active = True y current_amount < max_amount. Acepta inscripciones (pago pendiente/verificado).

En Curso: is_active = True y current_amount >= max_amount y cron de inicio activado (countdown). Durante En Curso: solo scores de usuarios inscritos y activados.

Finalizado: is_active = False (cuando termina el cron/metodolog√≠a). No admite scores de torneo; solo lectura para rankings y reparto.

Campo is_active se usa para distinguir Finalizado (false) vs abierto/en curso (true). El frontend deducir√° Open/En Curso con current_amount y duration/start_date.

3. Flujo de inscripci√≥n y pago (resumen)

Usuario hace click Unirme al torneo (bot√≥n deshabilitado si ya est√° inscrito en cualquier torneo).

Frontend env√≠a wallet asociada y tournament_id al endpoint /api/tournaments/register.

Backend valida:

Usuario autenticado.

user.usdt_wallet no repetida (en registro y aqu√≠ validar que wallet del body coincide con user.usdt_wallet).

El usuario no est√° registrado ya en otro torneo (consulta tournament_registrations con joins y torneos con is_active=True o no finalizados).

El torneo existe y is_active=True.

current_amount < max_amount (si es igual => En Curso, no permitir inscripci√≥n).

Si pasa validaciones, crear registro en tournament_registrations y crear Payment con is_active=False (pendiente) con tx_hash=null inicialmente o con tx_hash si el usuario lo agreg√≥.

Usuario realiza pago por TRC20 externamente y env√≠a tx_hash al endpoint /api/payments/confirm (adjunta tx_hash).

Backend registra tx_hash en payments y deja is_active=False hasta verificaci√≥n manual por admin.

Admin revisa tx en Tronscan y pulsa Verificar en dashboard ‚Üí backend actualiza payment.is_active=True y:

Actualiza tournament.current_amount += payment.amount.

Si current_amount >= max_amount: fijar tournament.start_date = now() (o calcular start), lanzar cron/countdown para duration. Mantener is_active=True.

Activar el registro del usuario (puede haber un campo adicional l√≥gico activated en la UI ‚Äî pero internamente, se puede considerar la existencia del Payment verificado como activaci√≥n).

Antes de verificaci√≥n, en frontend aparece payment status = Pendiente. Solo despu√©s de is_active=True el usuario puede jugar en modo torneo (scores ir√°n a leaderboard de torneo).

4. Control de scores (reglas)

Endpoint de env√≠o de score: /api/scores/submit

Input: user_id (o token auth), value, timestamp.

Backend determina destino:

Si el usuario est√° registrado y su registro est√° activado y el torneo est√° En Curso ‚Üí crear Score con mode='tournament' y tournament_id.

Si el usuario no est√° registrado o registro no activado ‚Üí create Score con mode='free' y tournament_id=null.

Validaci√≥n extra:

Si mode='tournament' y torneo NO est√° En Curso ‚Üí rechazar con 400.

Rechazar valores sospechosos (p. ej. negative, > l√≠mite razonable) y rate-limit por usuario/IP.

Lectura de scores: /api/scores/global (seg√∫n cufireUrl.json)

Backend provee la tabla adecuada dependiendo del contexto (Unity pedir√° y backend decide seg√∫n user token si debe devolver global top10 o torneo top10).

Response: top 10 ya ordenado por value y created_at.

5. Endpoints propuestos (REST) ‚Äî lista r√°pida

POST /api/auth/register ‚Äî registro (validar username, email, usdt_wallet √∫nico).

POST /api/auth/login ‚Äî JWT.

GET /api/tournaments ‚Äî listar torneos (incluye campos calculados: estado_display: Open/En Curso/Finalizado).

GET /api/tournaments/<id> ‚Äî detalle (incluye current_amount, payments list (admin)).

POST /api/tournaments/<id>/register ‚Äî crear tournament_registration y payment pending.

POST /api/payments/confirm ‚Äî a√±adir tx_hash a pago (usuario).

GET /api/payments/<tournament_id>/pending ‚Äî admin lista pagos pendientes.

POST /api/payments/<payment_id>/verify ‚Äî admin verifica tx (pone is_active=True, actualiza current_amount).

POST /api/scores/submit ‚Äî recibe score; backend decide destino.

GET /api/scores/global ‚Äî top10 global (o top10 torneo si se pasa token con user inscrito y torneo En Curso).

GET /api/admin/tournaments/<id>/participants ‚Äî admin lista participantes y botones activar/desactivar.

POST /api/admin/tournaments/<id>/distribute ‚Äî admin dispara reparto de premios (calculado por backend).

WebSocket namespace /ws/tournaments ‚Äî emitir eventos: payment_verified, tournament_started, score_update, tournament_finalized, prizes_distributed.

6. L√≥gica de transici√≥n (cron / worker)

Worker periodic (cada 30s / 1m):

Buscar torneos con is_active=True y current_amount >= max_amount y start_date is null ‚Üí si encuentra: set start_date=now() y programar end_date = start_date + duration.

Buscar torneos con is_active=True y end_date <= now() ‚Üí set is_active=False (Finalizado) y emitir evento tournament_finalized. Tambi√©n bloquear nueva inscripci√≥n.

Al finalizar: dejar listos datos para reparto de premios; reparto puede ser manual (admin pulsa distribuir) o autom√°tico si se integra TronGrid.

Notificar frontend via SocketIO para refrescar estados y habilitar/inhabilitar botones.

7. Reparto de premios (algoritmo)

Cuando finaliza torneo:

Sumar payments verificados para ese torneo ‚Üí prize_pool.

Obtener top N (seg√∫n regla; p.ej top3) o usar configuraci√≥n de % fijas (t√∫ indicas porcentajes fijos).

Crear payouts (tabla nueva ideal, pero si no quieres tocar DB: guardar registros en payments con tipo payout o usar logs). Recomendado: crear tabla payouts (no es obligatorio, pero muy √∫til).

Admin revisa y aprueba distribuci√≥n manual (si no hay integraci√≥n TronGrid).

Emisi√≥n de pagos manual: backend devuelve CSV o listado con wallets y montos para que el admin ejecute transferencia TRC20 y luego suba tx_hashs de pagos realizados.

8. Validaciones cr√≠ticas (a implementar en backend)

users.usdt_wallet √∫nico: en registro y al actualizar wallet.

users.username, users.email √∫nicos (reconfirmar constraints a nivel DB si existen; adem√°s handle exceptions de unique constraint).

Solo un tournament_registration por usuario activo: consultar tournament_registrations para torneos is_active=True o no finalizados.

Al recibir score, verificar que el usuario est√© autenticado y que la sesi√≥n Unity sea v√°lida (si Unity pasa un token/uid).

Sanitizar y validar tx_hash (longitud, formato) y verificar duplicados.

9. Real-time (WebSocket) & fallback

Primary: Flask-SocketIO con Redis (message queue) para escalar. Emitir eventos importantes (verificaciones, start, end, leaderboard updates).

Fallback: Si Unity o clientes no pueden usar WebSockets, proporcionar endpoints de polling como /api/tournaments/<id>/status y /api/scores/top con ETag/If-Modified-Since para menor carga.

Emitir score_update solo cuando hay cambios notables (por ejemplo cuando top10 cambia) para evitar spam.

10. Seguridad y consideraciones

Autenticaci√≥n: JWT tokens con expiraci√≥n. Endpoints sensibles admin protegidos con is_admin=True.

Rate limit: especialmente en /api/scores/submit y pagos.

Idempotencia: cuando admin verifica pagos o cuando usuario reenv√≠a tx_hash, evitar duplicados.

Verificaci√≥n tx_hash: por ahora manual; almacenar tx_hash y set is_active=False. Cuando admin marca verificado, actualizar is_active=True. (En futuro: TronGrid API para verificaci√≥n autom√°tica).

Logs: registrar todos los cambios de estado, verificaciones y pagos para auditor√≠a.

Protecciones anti-fraud: l√≠mite en n√∫mero de scores por minuto, heur√≠sticas para detectar valores imposibles.
