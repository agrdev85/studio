Te voy a explicarle bien la lÃ³gica para que me entiendas lo que quiero y me realices todo el backend con FastAPI, que veo que es fÃ¡cil de integrar, es decir, es robusto, con Quasar y despuÃ©s la integraciÃ³n con Unity por supuesto. Para la integraciÃ³n con Unity te voy a dar luego las diferentes pantallas que tengo en mi juego y que archivos se usan en cada pantalla para que los analices y lo integres directamente con todo este backend, con todo este ecosistema. Â¿QuÃ© quiero? La lÃ³gica es un, ya sabes que es de torneo, los jugadores pueden jugar libremente sin pagar y eso lleva una tabla clasificadora, es decir, la tabla se va actualizando siempre en tiempo real segÃºn la puntuaciÃ³n de los jugadores. Ahora, quiero hacer tambiÃ©n el torneo, es decir, para participar en el torneo ya el usuario si tiene que abonar o pagar 10 USDT para tener la posibilidad de participar en los beneficios de la reparticiÃ³n despuÃ©s de terminado el torneo, participar de los beneficios de la reparticiÃ³n, de la recaudaciÃ³n del torneo, del premio, para obtener, tiene derecho a los beneficios de la reparticiÃ³n del premio. De todos los recaudados se va a registrar en el torneo, si tienen una fecha lÃ­mite para registrarse en el torneo, si se va a hacer, puede ser asÃ­ o puede ser que se va llenando hasta un lÃ­mite que yo determine de usuarios, ya cuando llegue ese lÃ­mite de usuarios pues se cierra ya el torneo, se va llenando dinÃ¡micamente, de forma grÃ¡fica se ve en la pÃ¡gina como se va llenando una bolsa de dinero o una pirÃ¡mide de monedas que va llenÃ¡ndose, es una forma grÃ¡fica bastante atractiva y profesional donde se da al usuario el porcentaje que falta para que empiece el torneo, puede ser asÃ­, bÃ¡sicamente es eso, cada usuario cuando entre, siempre cuando se registre un usuario debe entrar, ya sea si va a participar en el torneo o no, tiene que entrar su billetera usdt para en el caso que decida posteriormente abonar los 10 usdt ya estÃ© habilitada esa billetera y entonces si participan ya en el torneo, que entre los 10 primeros lugares pueden ya entregarle, enviarle su parte del premio si entra dentro de los 10 primeros lugares, ahora todo eso, todo ese ecosistema tienes que preparÃ¡rmelo, dime si entendiste sÃ­ o no y procede hacerme todo eso.


SÃ­, entendÃ­ perfectamente. Has planteado una lÃ³gica muy clara para un sistema de torneos en lÃ­nea con dos tipos de participaciÃ³n (gratuita y pagada), tabla de puntuaciones en tiempo real, gestiÃ³n de pagos en USDT, y entrega de premios a los ganadores. Te resumo los puntos clave y luego te explico cÃ³mo vamos a organizar todo el desarrollo con FastAPI (backend), Quasar (frontend) y Unity (juego).
âœ… RESUMEN DE LA LÃ“GICA GENERAL:
1. Registro de usuarios

    Datos requeridos: email, contraseÃ±a, clave maestra para recuperaciÃ³n y direcciÃ³n USDT (TRC20, ERC20 o especificar).

    Se almacenan en la base de datos.

2. ParticipaciÃ³n

    Modo libre (gratuito):

        Cualquier usuario puede jugar sin pagar.

        Aparece en una tabla clasificatoria global.

    Modo torneo (pagado):

        Para participar, debe pagar 10 USDT.

        Solo jugadores que pagan aparecen en la tabla del torneo.

        Solo estos jugadores tienen derecho al premio.

        El torneo tiene:

            Fecha lÃ­mite para registro O

            LÃ­mite de jugadores registrados (el que llegue primero).

        Se muestra visualmente el progreso del fondo acumulado del torneo.

3. PremiaciÃ³n

    Al finalizar el torneo:

        Se calcula el total recaudado.

        El 50% se reparte entre los 10 primeros lugares con porcentajes especÃ­ficos.

        Se efectÃºa el pago a las billeteras USDT registradas.

        Se muestra en frontend los ganadores y sus premios.

4. Frontend

    Visual atractivo tipo gaming.

    Muestra pirÃ¡mide o barra de progreso del fondo recaudado.

    Cuenta regresiva o barra de llenado.

    Vista de tabla clasificatoria en tiempo real.

    Vista del torneo y sus reglas.

5. Unity

    Se conecta para:

        Login.

        Cargar perfil.

        Recuperar score global o de torneo.

        Subir puntuaciones en tiempo real.

        Mostrar tabla clasificatoria.

Esto es un ejemplo se puede ajustar los porcentajes luego. Por lo que el backend debe permitir administrar esto y el maximo de recaudacion antes de empesar el torneo es decir el monto a recaudar para que se complete el llenado una ves se llegue a ese monto empiesa el torneo, que durara el tiempo que se proporciona tamnbien en la configuracion.
Tu modelo explicado de forma clara

    Juego gratuito para todos

        Cualquier usuario puede jugar sin pagar.

        Pueden practicar, mejorar, subir en el ranking no competitivo.

    Torneo especial (modo competitivo)

        Pagar 10 USDT (vÃ­a wallet o cÃ³digo de activaciÃ³n).

        Al activar el torneo, se les habilita la participaciÃ³n por el ranking oficial.

        Se reparte el total recaudado entre los 10 mejores.

    DistribuciÃ³n del premio (ejemplo):

Puesto	Porcentaje del total recaudado
ðŸ¥‡ 1Âº	35â€¯%
ðŸ¥ˆ 2Âº	20â€¯%
ðŸ¥‰ 3Âº	15â€¯%
ðŸ¥‰ 4Âº	10â€¯%
ðŸ¥‰ 5Âº	7â€¯%
ðŸ¥‰ 6Âºâ€“10Âº 2â€¯% cada uno


Quiero que revises y me expliques bien como hago el flujo de registrar y la participacion paga y gratis de un torneo y en caso de pagar para participar un torneo como se paga ahi te dejo mis archivos para que resuelvas eso y me expliques bien sin tantos detalles pero si bien claro para entender. Dime como hago todo el flujo incluyendo una billetera TRC20 de prueba y automatizando todo el pago y la verificacion del mismo una ves sea realizado por un participante ya registrado. Simular tambien la entrada de puntos es decir tanto para el score global como para el del torneo como si estuviera ya conectado todo este al juego.

//Backend//

1- Cuando no me he registrado en ningun torneo lo que significa que no he pagado no tengo que ingresar el id del torneo para registrar mi score ya que ira al Leaderboard Global el id es necesario si estoy registrado en ese id de torneo y ahi si ira al Leaderboard del Torneo en donde este registrado. Actualmente si no he pagado no puedo entrar el score eso esta bien. Si estoy jugando sin pagar no tengo que ingresar id.
2- El score cuando es para torneo pagado no se debe dejar entrar el score hasta que no cierren las inscripciones ya sea hasta que se alcance el objetivo del monto maximo o alcance el maximo de Participantes una ves pase esto no se admiten mas registros a ese torneo y comienza la cuenta atras segun se haya definido en la variable de la base de datos duration.

//Frontend//
1- No manda alerta y debe hacerse con swettalert para todas las alertas ya sean de errores o cuando se hace un registro o login correcto.
2- El proceso de InscripciÃ³n al torneo no se realiza correctamente no sigue el flujo que me diste. Hacer el pago a la billetera que aun no esta definida usa una de prueba para mi app, Verificar mandando el hash de confirmacion y Registrar en torneo.
3- En el Dasboard del Admin debo poder Getionar usuarios es decir editarlos y eliminarlos asi como crear torneos que no me deja actualmente sin embargo desde swager el backend si puedo, debo poder al terminar el torneo cuando la cuenta regresiva de la variable duration llegue a cero se pondra la variable is_active a false y una ves se proceda  a dar clic desde el boton DISTRIBUIR PREMIOS (TOP 10) se mostrara el Leaderboard del Torneo en TournamentDetails como quedo el final de la tabla con los Usuario, Puntuacion, Premio(segun porcentaje segun tabla) y Fecha. esta es la tabla de porcentaje para repartir el premio:
ðŸ¥‡ 1Âº	35â€¯%
ðŸ¥ˆ 2Âº	20â€¯%
ðŸ¥‰ 3Âº	15â€¯%
ðŸ¥‰ 4Âº	10â€¯%
ðŸ¥‰ 5Âº	7â€¯%
ðŸ¥‰ 6Âºâ€“10Âº 2â€¯% cada uno
La tabla Leaderboard del Torneo delante del # debe tener un icono bien chulo segun su posicion sera el color del metal. Una ves duration llegue a cero tendre un boton para eliminar el  torneo en cascada para que se borre todo lo asociado a el.

//Frontend//
4- En esta ruta http://localhost:9000/#/tournaments/1 que es la de TournamentDetail el boton "unirme al torneo (10 USDT)" esta desabilitado


1- Para torneo pagado no se debe dejar entrar el score hasta que no cierren las inscripciones hasta que se alcance el objetivo del premio es decir que current_amount max_amount una ves pase esto no se admiten mas registros a ese torneo y comienza la cuenta atras segun se haya definido en la variable de la base de datos duration. En javaScript hacer un contador atras segun el tiempo definido en duration que esta en minutos, cuanto ese cronometro llegue a cero is_active = false el torneo dira en la pagina HomePage.vue  <q-badge color="purple-5" v-if="tournament.start_date">Cuenta atrÃ¡s</q-badge> cuenta atras se sustituye por Terminado y no se permiten mas scores ni mas registros al mismo lo que significa que cuando se de clic y se entre a la pagina TournamentDetail el boton de Unirme al Torneo(10 USDT) estara desabilitado porque is_active = false pero se seguira viendo hasta que se elimine el mismo y ahi no se vera logicamente en HomePage.vue. En TournamentDetails debe mostrar un boton que diga Distribuir Premio que mostrara una ventana swettalert con la distribuciondashboard del Premio segun monto total el objetivo(max_amount)(segun porcentaje segun tabla)  esta es la tabla de porcentaje para repartir el premio:
ðŸ¥‡ 1st: 30% 
ðŸ¥ˆ 2nd: 18% 
ðŸ¥‰ 3rd: 13%
ðŸ¥‰ 4th: 9% 
ðŸ¥‰ 5th: 5% 
ðŸ¥‰ 6thâ€“10th: 5% cada uno. Este calculo se hara con javascript y muestra por ejemplo digamos que max_amount = 1000 USDT se aplica los % de la tabla en los 10 lugares. 
Arregla en el d
En la pagina DashboardPage.vue cuando se entra como Administrador la parte de gestionar usuarios si funciona, el formulario para crear torneo no funciona arreglar eso ver en tournament.py ver el enpoint /api/tournaments/ ahi se hace ese registro actualmente cuando escojo una fecha se borra la otra no se porque. Se debe poder eliminar torneos para ello se debe crear ese enpoint es decir la funcion que ahora no existe y poder eliminar desde la tabla Torneos. Se elimina en cascada las referencias de las tablas payments y tournament_registrations.

2-  El proceso de InscripciÃ³n al torneo no se realiza correctamente no sigue el flujo. Hacer el registro al torneo solo si no se ha alcanzado el monto_maximo o alcance el maximo de Participantes, Registrar en torneo segun enpoint /api/tournaments/{id}/register y Verificar mandando el hash de confirmacion(Si el tx_hash de la tabla payments lo compruebo manualmente y si es correcto le pongo en la tabla payments hay que crear un is_active lo pongo en true si es correcto y false en caso contrario esta logica tambien debo manejarla desde el DashboardPage.vue).

En Premio Total en la pagina Inicio se debe ver una imagen vectorial de una copa con efecto de llenado con css espectacular como se hace en vue ejemple en el file CupFlame.vue.

En algÃºn lugar cuando me logueo como Administrador debe poder gestionar tanto usuarios como torneos(Crear,Actualizar y Eliminar)

El proceso de inscripciÃ³n a un torneo y del pago de los 10 usdt para participar en el reparto del premio, y verificaciÃ³n del mismo para activar a ese usuario como lo manejas y donde, si no esta hecho hazlo bien profesional.

Los ficheros de Unity Server.cs y web.cs (manejan la logica de Login, leer u escribir puntuaciones, entre otras) no deben ser tocados se quedaran intactos los proporciono para que toda la lÃ³gica del backend y frontend se basen en ellos por ejemplo cuando se realiza un nuevo hiscore ya tuvimos que habernos loguiado en Unity por lo que el juego maneja y sabe que usuario es, el backend debe manejar bien que datos mostrar para poblar la tabla de hiscore dentro de Unity en dependencia si el usuario esta jugando gratis o esta inscrito en un torneo me parece conveniente que un usuario este inscrito solo en un torneo no se como lo manejaras mejor, asÃ­ mismo para escribir puntos debe determinar el backend hacia donde van en dependencia si el usuario esta jugando gratis o esta inscrito en un torneo.

No se si tienes esto previsto hay que hacer algo como esto una lÃ³gica bien elaborada para torneo, propon una mejor que maneje todo. Ejemplo, propÃ³n una mejor a esta aquÃ­ esta. Para torneo pagado no se debe dejar entrar el score hasta que no cierren las inscripciones hasta que se alcance el objetivo del premio es decir que current_amount max_amount una ves pase esto no se admiten mas registros a ese torneo y comienza la cuenta atras segun se haya definido en la variable de la base de datos duration. En javaScript hacer un contador atras segun el tiempo definido en duration que esta en minutos, cuanto ese cronometro llegue a cero is_active = false el torneo dira en la pagina HomePage.vue  <q-badge color="purple-5" v-if="tournament.start_date">Cuenta atrÃ¡s</q-badge> cuenta atras se sustituye por Terminado y no se permiten mas scores ni mas registros al mismo lo que significa que cuando se de clic y se entre a la pagina TournamentDetail el boton de Unirme al Torneo(10 USDT) estara desabilitado porque is_active = false pero se seguira viendo hasta que se elimine el mismo y ahi no se vera logicamente en HomePage.vue. En TournamentDetails debe mostrar un boton que diga Distribuir Premio que mostrara una ventana swettalert con la distribuciondashboard del Premio segun monto total el objetivo(max_amount)(segun porcentaje segun tabla)  esta es la tabla de porcentaje para repartir el premio:

ðŸ¥‡ 1st: 30% 

ðŸ¥ˆ 2nd: 18% 

ðŸ¥‰ 3rd: 13%

ðŸ¥‰ 4th: 9% 

ðŸ¥‰ 5th: 5% 

ðŸ¥‰ 6thâ€“10th: 5% cada uno 

//Modelos//

# user.py
from app.db.base import Base
from sqlalchemy import Boolean, Column, Integer, String

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True)
    email = Column(String, unique=True, index=True)
    hashed_password = Column(String)
    usdt_wallet = Column(String, nullable=True)
    is_active = Column(Boolean, default=True)
    is_tournament_participant = Column(Boolean, default=False)
    is_admin = Column(Boolean, default=False)  # Nuevo campo para administrador

# tournament.py    
from app.db.base import Base
from sqlalchemy import Column, Integer, String, Float, DateTime, Boolean
from datetime import datetime

class Tournament(Base):
    __tablename__ = "tournaments"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    description = Column(String, nullable=True)
    max_players = Column(Integer, nullable=True)
    max_amount = Column(Float, nullable=True)  # Monto mÃ¡ximo recaudado
    current_amount = Column(Float, default=0.0)
    registration_fee = Column(Float, default=10.0)  # 10 USDT
    start_date = Column(DateTime, nullable=True)
    end_date = Column(DateTime, nullable=True)
    duration = Column(Integer, nullable=True)  # En minutos
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)

# tournament_registration.py
from app.db.base import Base
from sqlalchemy import Column, Integer, ForeignKey, DateTime
from datetime import datetime

class TournamentRegistration(Base):
    __tablename__ = "tournament_registrations"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)
    tournament_id = Column(Integer, ForeignKey('tournaments.id'), nullable=False)
    registered_at = Column(DateTime, default=datetime.utcnow)

# payment.py
from sqlalchemy import Column, Integer, String, ForeignKey, DateTime, Float, Boolean
from app.db.base import Base

class Payment(Base):
    __tablename__ = "payments"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete='CASCADE'))
    tournament_id = Column(Integer, ForeignKey("tournaments.id", ondelete='CASCADE'))
    tx_hash = Column(String, nullable=True)
    amount = Column(Float)
    created_at = Column(DateTime)
    is_active = Column(Boolean, default=False)

# score.py
from sqlalchemy import Column, Integer, ForeignKey, String, DateTime
from app.db.base import Base
from datetime import datetime

class Score(Base):
    __tablename__ = "scores"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    tournament_id = Column(Integer, ForeignKey("tournaments.id"), nullable=True)
    value = Column(Integer)
    mode = Column(String)  # 'free' o 'tournament'
    created_at = Column(DateTime, default=datetime.utcnow)
    

//Requisitos Funcionales//
1- En registrar user no puede haber una billetera repetida en el sistema(validar en el backend eso), al igual que el nombre y email no deben estar repetidos en la base de datos(Estos si creo estan validados confirmar eso).
2- Un usuario solo puede estar registrado a un torneo, por lo que hay que verificar si ya esta registrado en algun torneo y no permitir pagar para registrarse en otro.
3- No debe permitir entrar scores al Leaderboard del Torneo si este no esta En Curso, cuando esta en estado Open o Finalizado no se puede permitir estrar scores. Cuando un usuario no esta inscrito a un torneo significa que esta jugando en modo gratis y el score que haga en el juego sera enviado al Leaderboard Global. 
Los ficheros de Unity Server.cs y web.cs (manejan la logica de Login, leer y escribir puntuaciones, entre otras) no deben ser tocados se quedaran intactos los proporciono para que toda la lÃ³gica del backend y frontend se basen en ellos por ejemplo cuando se realiza un nuevo hiscore ya tuvimos que habernos loguiado en Unity por lo que el juego maneja y sabe que usuario es, el backend debe manejar bien que datos mostrar(leer puntos) para poblar la tabla de hiscore dentro de Unity en dependencia si el usuario esta jugando gratis o esta inscrito en un torneo me parece conveniente que un usuario este inscrito solo en un torneo, asÃ­ mismo para (escribir puntos) debe determinar el backend hacia donde van en dependencia si el usuario esta jugando gratis o esta inscrito en un torneo.

4- Rectificar el proceso completo de inscripcion al torneo. El proceso de InscripciÃ³n al torneo no se realiza correctamente no sigue el flujo. Hacer el registro al torneo solo si el usuario no esta registrado en un torneo y si en la tabla tournaments current_amount < max_amount estado en frontend" Open(significa abierto a inscripciones), si current_amount = max_amount(que es el objetivo) se pone "estado en fronted" En Curso(significa que esta iniciado la cuenta atras con un cronometro segun el tiempo puesto en la tabla tournaments en el campo duration y el torneo ya cerro las inscripciones). En estos dos casos en la tabla tournaments el campo is_active=true. Cuando ese cronometro llegue a cero en la tabla tournaments el campo is_active=false se pone "estado en fronted" Finalizado(significa que el torneo termino). Actualmente el usuario se inscribe al torneo, hace el pago y manda el thash de la confirmacion del mismo y se le debe poner en el frontend estado pendiente en la tabla payments el campo is_active = false, el administrador manualmente lo verifica y le cambia el estado a verificado en el frontend en la tabla payments el campo is_active inicialmente en false se le cambia a true. En el frontend en la parte de detalles del torneo hay un boton Unirme al torneo este estara desactivado o activado en dependencia si el usurio logueado esta inscrito en un torneo(Esta activo el boton si el usuario no esta inscrito en un torneo en caso contrario esta desabilitado) este booton lanza un formulario que debe recoger la billetera del usuario logueado. Desde el DashboardPage.vue con mi usuario administrador ya puedo escoger de un torneo los usuarios registrados a el y activarlos odesactivarlos actualmente esta implementado pero hay que revisar todo el proceso antes descrito para lograr e integrar todo de la mejor manera siguiendo las mejores practicas sin modificar la base de datos actual. Buscar la manera mas logica para hacer la inscripcion.

cufireUrl.json actualizar segun los enpoint del backend que manejen la logica: 
```json
{
  "login": "http://your-domain/api/auth/login",
  "register": "http://your-domain/api/auth/register",
  "readscore": "http://your-domain/api/scores/global", //logica manejada x backend si user esta jugando gratis o no
  "writescore": "http://your-domain/api/scores/submit" //logica manejada x backend si user esta jugando gratis o no
}
```
Este es mi repositorio. Consultar siempre para estar al dÃ­a con las Ãºltimas actualizaciones
https://github.com/agrdev85/FPS-CUFIRE-Server 

Listo para clonar 
https://github.com/agrdev85/FPS-CUFIRE-Server.git

Google Drive
https://drive.google.com/drive/folders/1acgGCrdPHR8uW-aORCqlXfOJMWbbbMsJ?usp=sharing
 
Antes de hacer codigo planteame la mejor manera de hacer esto sin tocar los archivos de Unity web y Server, ni la base de datos. 
siempre  hÃ¡blame en espaÃ±ol

1. Principio de diseÃ±o

No tocar Unity: Unity seguirÃ¡ usando los endpoints definidos en cufireUrl.json. El backend debe adaptarse a cÃ³mo Unity envÃ­a login/requests (ya provisto).

No cambiar esquema de BD: Usaremos las tablas existentes y aÃ±adiremos validaciones y consultas sobre ellas. No migraciones.

SeparaciÃ³n de responsabilidades:

API REST (Flask) para autenticaciÃ³n, registro, torneos, pagos, scores, administraciÃ³n.

Real-time: Flask-SocketIO (con Redis como message broker si se escala). Unity podrÃ¡ usar WS si lo soporta, si no, el frontend poll/long-poll.

Worker/cron: tarea periÃ³dica que actualiza estados de torneos (Open â†’ En Curso â†’ Finalizado) y calcula premios cuando finaliza. Inicialmente puede ser un cron job o un proceso separado en el mismo servidor.

2. Estados de torneo y reglas (definiciÃ³n concreta)

Estado interno inferido en backend (no se aÃ±ade campo nuevo):

Open: is_active = True y current_amount < max_amount. Acepta inscripciones (pago pendiente/verificado).

En Curso: is_active = True y current_amount >= max_amount y cron de inicio activado (countdown). Durante En Curso: solo scores de usuarios inscritos y activados.

Finalizado: is_active = False (cuando termina el cron/metodologÃ­a). No admite scores de torneo; solo lectura para rankings y reparto.

Campo is_active se usa para distinguir Finalizado (false) vs abierto/en curso (true). El frontend deducirÃ¡ Open/En Curso con current_amount y duration/start_date.

3. Flujo de inscripciÃ³n y pago (resumen)

Usuario hace click Unirme al torneo (botÃ³n deshabilitado si ya estÃ¡ inscrito en cualquier torneo).

Frontend envÃ­a wallet asociada y tournament_id al endpoint /api/tournaments/register.

Backend valida:

Usuario autenticado.

user.usdt_wallet no repetida (en registro y aquÃ­ validar que wallet del body coincide con user.usdt_wallet).

El usuario no estÃ¡ registrado ya en otro torneo (consulta tournament_registrations con joins y torneos con is_active=True o no finalizados).

El torneo existe y is_active=True.

current_amount < max_amount (si es igual => En Curso, no permitir inscripciÃ³n).

Si pasa validaciones, crear registro en tournament_registrations y crear Payment con is_active=False (pendiente) con tx_hash=null inicialmente o con tx_hash si el usuario lo agregÃ³.

Usuario realiza pago por TRC20 externamente y envÃ­a tx_hash al endpoint /api/payments/confirm (adjunta tx_hash).

Backend registra tx_hash en payments y deja is_active=False hasta verificaciÃ³n manual por admin.

Admin revisa tx en Tronscan y pulsa Verificar en dashboard â†’ backend actualiza payment.is_active=True y:

Actualiza tournament.current_amount += payment.amount.

Si current_amount >= max_amount: fijar tournament.start_date = now() (o calcular start), lanzar cron/countdown para duration. Mantener is_active=True.

Activar el registro del usuario (puede haber un campo adicional lÃ³gico activated en la UI â€” pero internamente, se puede considerar la existencia del Payment verificado como activaciÃ³n).

Antes de verificaciÃ³n, en frontend aparece payment status = Pendiente. Solo despuÃ©s de is_active=True el usuario puede jugar en modo torneo (scores irÃ¡n a leaderboard de torneo).

4. Control de scores (reglas)

Endpoint de envÃ­o de score: /api/scores/submit

Input: user_id (o token auth), value, timestamp.

Backend determina destino:

Si el usuario estÃ¡ registrado y su registro estÃ¡ activado y el torneo estÃ¡ En Curso â†’ crear Score con mode='tournament' y tournament_id.

Si el usuario no estÃ¡ registrado o registro no activado â†’ create Score con mode='free' y tournament_id=null.

ValidaciÃ³n extra:

Si mode='tournament' y torneo NO estÃ¡ En Curso â†’ rechazar con 400.

Rechazar valores sospechosos (p. ej. negative, > lÃ­mite razonable) y rate-limit por usuario/IP.

Lectura de scores: /api/scores/global (segÃºn cufireUrl.json)

Backend provee la tabla adecuada dependiendo del contexto (Unity pedirÃ¡ y backend decide segÃºn user token si debe devolver global top10 o torneo top10).

Response: top 10 ya ordenado por value y created_at.

5. Endpoints propuestos (REST) â€” lista rÃ¡pida

POST /api/auth/register â€” registro (validar username, email, usdt_wallet Ãºnico).

POST /api/auth/login â€” JWT.

GET /api/tournaments â€” listar torneos (incluye campos calculados: estado_display: Open/En Curso/Finalizado).

GET /api/tournaments/<id> â€” detalle (incluye current_amount, payments list (admin)).

POST /api/tournaments/<id>/register â€” crear tournament_registration y payment pending.

POST /api/payments/confirm â€” aÃ±adir tx_hash a pago (usuario).

GET /api/payments/<tournament_id>/pending â€” admin lista pagos pendientes.

POST /api/payments/<payment_id>/verify â€” admin verifica tx (pone is_active=True, actualiza current_amount).

POST /api/scores/submit â€” recibe score; backend decide destino.

GET /api/scores/global â€” top10 global (o top10 torneo si se pasa token con user inscrito y torneo En Curso).

GET /api/admin/tournaments/<id>/participants â€” admin lista participantes y botones activar/desactivar.

POST /api/admin/tournaments/<id>/distribute â€” admin dispara reparto de premios (calculado por backend).

WebSocket namespace /ws/tournaments â€” emitir eventos: payment_verified, tournament_started, score_update, tournament_finalized, prizes_distributed.

6. LÃ³gica de transiciÃ³n (cron / worker)

Worker periodic (cada 30s / 1m):

Buscar torneos con is_active=True y current_amount >= max_amount y start_date is null â†’ si encuentra: set start_date=now() y programar end_date = start_date + duration.

Buscar torneos con is_active=True y end_date <= now() â†’ set is_active=False (Finalizado) y emitir evento tournament_finalized. TambiÃ©n bloquear nueva inscripciÃ³n.

Al finalizar: dejar listos datos para reparto de premios; reparto puede ser manual (admin pulsa distribuir) o automÃ¡tico si se integra TronGrid.

Notificar frontend via SocketIO para refrescar estados y habilitar/inhabilitar botones.

7. Reparto de premios (algoritmo)

Cuando finaliza torneo:

Sumar payments verificados para ese torneo â†’ prize_pool.

Obtener top N (segÃºn regla; p.ej top3) o usar configuraciÃ³n de % fijas (tÃº indicas porcentajes fijos).

Crear payouts (tabla nueva ideal, pero si no quieres tocar DB: guardar registros en payments con tipo payout o usar logs). Recomendado: crear tabla payouts (no es obligatorio, pero muy Ãºtil).

Admin revisa y aprueba distribuciÃ³n manual (si no hay integraciÃ³n TronGrid).

EmisiÃ³n de pagos manual: backend devuelve CSV o listado con wallets y montos para que el admin ejecute transferencia TRC20 y luego suba tx_hashs de pagos realizados.

8. Validaciones crÃ­ticas (a implementar en backend)

users.usdt_wallet Ãºnico: en registro y al actualizar wallet.

users.username, users.email Ãºnicos (reconfirmar constraints a nivel DB si existen; ademÃ¡s handle exceptions de unique constraint).

Solo un tournament_registration por usuario activo: consultar tournament_registrations para torneos is_active=True o no finalizados.

Al recibir score, verificar que el usuario estÃ© autenticado y que la sesiÃ³n Unity sea vÃ¡lida (si Unity pasa un token/uid).

Sanitizar y validar tx_hash (longitud, formato) y verificar duplicados.

9. Real-time (WebSocket) & fallback

Primary: Flask-SocketIO con Redis (message queue) para escalar. Emitir eventos importantes (verificaciones, start, end, leaderboard updates).

Fallback: Si Unity o clientes no pueden usar WebSockets, proporcionar endpoints de polling como /api/tournaments/<id>/status y /api/scores/top con ETag/If-Modified-Since para menor carga.

Emitir score_update solo cuando hay cambios notables (por ejemplo cuando top10 cambia) para evitar spam.

10. Seguridad y consideraciones

AutenticaciÃ³n: JWT tokens con expiraciÃ³n. Endpoints sensibles admin protegidos con is_admin=True.

Rate limit: especialmente en /api/scores/submit y pagos.

Idempotencia: cuando admin verifica pagos o cuando usuario reenvÃ­a tx_hash, evitar duplicados.

VerificaciÃ³n tx_hash: por ahora manual; almacenar tx_hash y set is_active=False. Cuando admin marca verificado, actualizar is_active=True. (En futuro: TronGrid API para verificaciÃ³n automÃ¡tica).

Logs: registrar todos los cambios de estado, verificaciones y pagos para auditorÃ­a.

Protecciones anti-fraud: lÃ­mite en nÃºmero de scores por minuto, heurÃ­sticas para detectar valores imposibles.
